<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Шпаргалки по Java</title>
	<link rel="stylesheet" href="css/bootstrap.min.css">
	<link rel="stylesheet" href="css/main.css">
</head>
<body>

<div class="container">
	<nav class="navbar sticky-top navbar-light bg-light top-navbar">
		<a class="navbar-brand" href="index.html">Установка Java</a>
		<a class="navbar-brand" href="compile.html">Компиляция</a>
		<a class="navbar-brand" href="datatypes.html">Типы данных</a>
		<a class="navbar-brand" href="collections.html">Коллекции</a>
	</nav>

	<div class="content col-12">
		<div class="row mb-5">
			<h4>Иерархия коллекций</h4>
			<br>
			<img class="img-fluid" src="img/col1.png" alt="collection 1">
		</div>
		<div class="row mb-5">
			<h4>Интерфейс Map</h4>
			<img class="img-fluid" src="img/map.png" alt="map">
			<p class="mt-3 mb-3"><code class="fw-bold">Hashtable</code> — реализация такой структуры данных, как хэш-таблица. Она не позволяет использовать null в качестве значения или ключа. Эта коллекция была реализована раньше, чем Java Collection Framework, но в последствии была включена в его состав. Как и другие коллекции из Java 1.0, Hashtable является синхронизированной (почти все методы помечены как synchronized). Из-за этой особенности у неё имеются существенные проблемы с производительностью и, начиная с Java 1.2, в большинстве случаев рекомендуется использовать другие реализации интерфейса Map ввиду отсутствия у них синхронизации.</p>
			<p class="mt-3 mb-3"><code class="fw-bold">HashMap</code> — коллекция является альтернативой Hashtable. Двумя основными отличиями от Hashtable являются то, что HashMap не синхронизирована и HashMap позволяет использовать null как в качестве ключа, так и значения. Так же как и Hashtable, данная коллекция не является упорядоченной: порядок хранения элементов зависит от хэш-функции. Добавление элемента выполняется за константное время O(1), но время удаления, получения зависит от распределения хэш-функции. В идеале является константным, но может быть и линейным O(n). Более подробную информацию о HashMap можно почитать здесь (актуально для Java < 8).</p>
			<p class="mt-3 mb-3"><code class="fw-bold">LinkedHashMap</code> — это упорядоченная реализация хэш-таблицы. Здесь, в отличии от HashMap, порядок итерирования равен порядку добавления элементов. Данная особенность достигается благодаря двунаправленным связям между элементами (аналогично LinkedList). Но это преимущество имеет также и недостаток — увеличение памяти, которое занимет коллекция. Более подробная информация изложена в этой статье.</p>
			<p class="mt-3 mb-3"><code class="fw-bold">TreeMap</code> — реализация Map основанная на красно-чёрных деревьях. Как и LinkedHashMap является упорядоченной. По-умолчанию, коллекция сортируется по ключам с использованием принципа "natural ordering", но это поведение может быть настроено под конкретную задачу при помощи объекта Comparator, который указывается в качестве параметра при создании объекта TreeMap.</p>
			<p class="mt-3 mb-3"><code class="fw-bold">WeakHashMap</code> — реализация хэш-таблицы, которая организована с использованием weak references. Другими словами, Garbage Collector автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элеметна нет жёстких ссылок.</p>
		</div>
		<div class="row mb-5">
			<h4>Интерфейс List</h4>
			<img class="img-fluid" src="img/list.png" alt="list">
			<p class="mt-3 mb-3">Реализации этого интерфейса представляют собой упорядоченные коллекции. Кроме того, разработчику предоставляется возможность доступа к элементам коллекции по индексу и по значению (так как реализации позволяют хранить дубликаты, результатом поиска по значению будет первое найденное вхождение).</p>

			<p class="mt-3 mb-3"><code class="fw-bold">Vector</code> — реализация динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента. Vector появился в JDK версии Java 1.0, но как и Hashtable, эту коллекцию не рекомендуется использовать, если не требуется достижения потокобезопасности. Потому как в Vector, в отличии от других реализаций List, все операции с данными являются синхронизированными. В качестве альтернативы часто применяется аналог — ArrayList.</p>
			<p class="mt-3 mb-3"><code class="fw-bold">Stack</code> — данная коллекция является расширением коллекции Vector. Была добавлена в Java 1.0 как реализация стека LIFO (last-in-first-out). Является частично синхронизированной коллекцией (кроме метода добавления push()). После добавления в Java 1.6 интерфейса Deque, рекомендуется использовать именно реализации этого интерфейса, например ArrayDeque.</p>
			<p class="mt-3 mb-3"><code class="fw-bold">ArrayList</code> как и Vector является реализацией динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента. Как можно догадаться из названия, его реализация основана на обычном массиве. Данную реализацию следует применять, если в процессе работы с коллекцией предплагается частое обращение к элементам по индексу. Из-за особенностей реализации поиндексное обращение к элементам выполняется за константное время O(1). Но данную коллекцию рекомендуется избегать, если требуется частое удаление/добавление элементов в середину коллекции.</p>
			<p class="mt-3 mb-3"><code class="fw-bold">LinkedList </code> — ещё одна реализация List. Позволяет хранить любые данные, включая null. Особенностью реализации данной коллекции является то, что в её основе лежит двунаправленный связный список (каждый элемент имеет ссылку на предыдущий и следующий). Благодаря этому, добавление и удаление из середины, доступ по индексу, значению происходит за линейное время O(n), а из начала и конца за константное O(1). Так же, ввиду реализации, данную коллекцию можно использовать как стек или очередь. Для этого в ней реализованы соответствующие методы.</p>
		</div>
		<div class="row mb-5">
			<h4>Интерфейс Set</h4>
			<img class="img-fluid" src="img/set.png" alt="set">
			<p class="mt-3 mb-3">Представляет собой неупорядоченную коллекцию, которая не может содержать дублирующиеся данные. Является программной моделью математического понятия «множество».</p>

			<p class="mt-3 mb-3"><code class="fw-bold">HashSet</code> — реализация интерфейса Set, базирующаяся на HashMap. Внутри использует объект HashMap для хранения данных. В качестве ключа используется добавляемый элемент, а в качестве значения — объект-пустышка (new Object()). Из-за особенностей реализации порядок элементов не гарантируется при добавлении.</p>
			<p class="mt-3 mb-3"><code class="fw-bold">LinkedHashSet</code>  — отличается от HashSet только тем, что в основе лежит LinkedHashMap вместо HashMap. Благодаря этому отличию порядок элементов при обходе коллекции является идентичным порядку добавления элементов.</p>
			<p class="mt-3 mb-3"><code class="fw-bold">TreeSet</code> — аналогично другим классам-реализациям интерфейса Set содержит в себе объект NavigableMap, что и обуславливает его поведение. Предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием "natural ordering".</p>
		</div>
		<div class="row mb-5">
			<h4>Интерфейс Queue</h4>
			<img class="img-fluid" src="img/queue.png" alt="queue">
			<p class="mt-3 mb-3">Этот интерфейс описывает коллекции с предопределённым способом вставки и извлечения элементов, а именно — очереди FIFO (first-in-first-out). Помимо методов, определённых в интерфейсе Collection, определяет дополнительные методы для извлечения и добавления элементов в очередь. Большинство реализаций данного интерфейса находится в пакете java.util.concurrent</p>

			<p class="mt-3 mb-3"><code class="fw-bold">PriorityQueue</code> — является единственной прямой реализацией интерфейса Queue (была добавлена, как и интерфейс Queue, в Java 1.5), не считая класса LinkedList, который так же реализует этот интерфейс, но был реализован намного раньше. Особенностью данной очереди является возможность управления порядком элементов. По-умолчанию, элементы сортируются с использованием «natural ordering», но это поведение может быть переопределено при помощи объекта Comparator, который задаётся при создании очереди. Данная коллекция не поддерживает null в качестве элементов.</p>
			<p class="mt-3 mb-3"><code class="fw-bold">ArrayDeque</code> — реализация интерфейса Deque, который расширяет интерфейс Queue методами, позволяющими реализовать конструкцию вида LIFO (last-in-first-out). Интерфейс Deque и реализация ArrayDeque были добавлены в Java 1.6. Эта коллекция представляет собой реализацию с использованием массивов, подобно ArrayList, но не позволяет обращаться к элементам по индексу и хранение null. Как заявлено в документации, коллекция работает быстрее чем Stack, если используется как LIFO коллекция, а также быстрее чем LinkedList, если используется как FIFO.</p>
		</div>
		<div class="row mb-5">
			<h4>Сложность алгоритмов методов коллекций</h4>
			<p class="mt-3 mb-3">Java Collections Framework содержит большое количество различных структур данных, доступных в JDK «из коробки», которые в большинстве случаев покрывают все потребности при реализации логики приложения. Сравнение временных характеристик основных коллекций, которые зачастую используются в разработке приложений приведено в таблице:</p>
			<img class="img-fluid" src="img/complexity.png" alt="Сложность алгоритмов коллекций java">
		</div>
	</div>

	<nav class="navbar sticky-bottom navbar-light bg-light top-navbar">
		<a class="navbar-brand" href="index.html">Установка Java</a>
		<a class="navbar-brand" href="compile.html">Компиляция</a>
		<a class="navbar-brand" href="datatypes.html">Типы данных</a>
		<a class="navbar-brand" href="collections.html">Коллекции</a>
	</nav>
</div>

<script src="js/main.js"></script>
</body>
</html>
